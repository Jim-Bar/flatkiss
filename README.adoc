= FlatKiss
:1: https://en.wikipedia.org/wiki/KISS_principle
:2: https://google.github.io/styleguide/cppguide.html
:3: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1204r0.html

FlatKiss is a 2D tile based toy game engine.

== Paradigm

First and foremost the mindset driving this project is *_simple_*. It embraces the {1}[KISS] principle. Simplicity comes
before performance / optimization. Simple is different from easy. It is easy to complicate things, but hard to make them
simple. In this project, before implementing anything the question which is asked is: "_Is this simple?_". If it is not,
then revamp it.

Concerns about performance only come after. When the project starts behaving slowly, *then* things can be torn to
accomodate performance. This is C++ with SDL, so unless doing crazy things performance often comes out of the box.

== Terminology

FlatKiss is spelled like this depending on the chosen case:

. FlatKiss
. flatkiss
. FLATKISS

IMPORTANT: No hyphen `-` or underscore `_` in the name, ever.

== How to build

The project uses CMake. There are not many dependencies, yet the simplest way is to use a Docker container which
contains everything needed.

WARNING: The Docker image is not yet accessible anywhere. The only way to get it is to build it. There is a temporary
script which does that in addition to generating binary files containing the assets for the engine to use:
`setup_dev_environment.sh`. Note that it will download pictures which must be converted manually to the BMP file format.

When the image is ready, the recommended way is to use Visual Studio Code. The only extension required is _Remote -
Containers_, install it first. Then open the directory of the project with Visual Studio Code, and it will detect that a
Docker image can be used for the project. Follow the recommendations of Visual Studio Code (such as configuring the
project, etc...), then click "Build".

== How to run

Assets are required for the engine to actually show something. Refer to the previous section for how to generate them.
Then, outside of the Docker container, run the binary generated by CMake in the `build/` directory (it might require to
be ran from the project's root directory in order to find the assets).

IMPORTANT: SDL2 must be installed.

== Binary files format

NOTE: Everything is little-endian.

NOTE: In the tables below, names in `PascalCase` are just values, names in `MACRO_CASE` are other bytefields.

NOTE: In the tables below, _(continued)_ means a value of bytefield which extends onto the next row.

WARNING: In the tables below, sometimes values or bytefields follow a _(...)_ on a new row. This does not necessarily means that this value / bytefields is padded to 0. In all cases, this field just follows whatever was before without a gap.

=== Level

The file `levels.bin` contains any number of `LEVEL` concatenated together.

.`LEVEL`
|===
|0|1|2|3|4|5|6|7

2+|`Width` 2+|`Height` 2+|`SpritesetIndex` 2+|`AnimationGroupIndex`
2+|`TilesToSolidsMapIndex` 2+|`NumberOfCharacters` 4+|`CHARACTER_IN_LEVEL` (0)
2+|(continued) 6+|`CHARACTER_IN_LEVEL` (1)
2+| (...) 6+|`CHARACTER_IN_LEVEL` (`NumberOfCharacters` - 1)
2+|`TileIndex` (0) 2+|`TileIndex` (1) 2+| (...) 2+|`TileIndex` (`Width` * `Height` - 1)
|===

`Width`:: Width of the level in tiles.
`Height`:: Height of the level in tiles.
`SpritesetIndex`:: Index of the spriteset to use for the level.
`AnimationGroupIndex`:: Index of the group of animations to use for the level.
`TilesToSolidsMapIndex`:: Index of the map of tiles to solids to use for the level.
`NumberOfCharacters`:: Number of characters in the level.
`TileIndex`:: Tile index in the tileset. The first tile index represents the top left tile in the level, then next tile
index represents the one to its right, and so on until reaching the bottom right tile in the level.

.`CHARACTER_IN_LEVEL`
|===
|0|1|2|3|4|5

2+|`CharacterIndex` 2+|`PositionX` 2+|`PositionY`
|===

`CharacterIndex`:: Index of the character to use.
`PositionX`:: Location in the level of the character in tiles along the horizontal axis.
`PositionY`:: Location in the level of the character in tiles along the vertical axis.

=== Animations

The file `animations.bin` contains any number of `ANIMATION_GROUP` concatenated together.

.`ANIMATION_GROUP`
|===
|0|1|2|3|4|5|6|7

2+|`AnimationGroupIndex` 2+|`NumberOfAnimations` 4+|`ANIMATION` (0)
4+|`ANIMATION` (1) 4+|(...)
4+|`ANIMATION` (`NumberOfAnimations` - 1) 4+|
|===

`AnimationGroupIndex`:: Unique identifier of this group, can be anything.
`NumberOfAnimations`:: Number of animations this group is made of.

.`ANIMATION`
|===
|0|1|2|3|4|5|6|7

|`Period` |`Duration` 2+|`SpriteIndex` (0) 2+|`SpriteIndex` (1) 2+|(...)
2+|`SpriteIndex` (`Period` - 1) 6+|
|===

`Period`:: Number of sprites making up this animation.
`Duration`:: How many ticks pass before the animation goes to the next step / sprite.
`SpriteIndex`:: Sprite index in the spriteset. The first sprite index is the first frame of the animation, the second
sprite index the second frame, etc...

TIP: The first sprite index in the animation also defines which animation is played for a particular sprite (in a level
or of a character). A group of animations is associated with a level / character. Then the animation for a particular
sprite is the one starting with that sprite index.

=== Collisions

Collisions are handled through the use of shapes which cannot be crossed. The shapes available are rectangles and
ellipses. Those are gathered in groups making up _solids_. A solid is a collection of those shapes which cannot be
crossed.

Rectangle are delimitated by an origin (x, y) at the top left of the sprite, and a size (width, height). They are
associated with sprites indices. For instance, if sprites are 16x16 pixels, the collision of origin (12, 12) and size
(4, 4) makes a sprite not walkable on the square of 4x4 pixels at its bottom right.

Ellipse are delimitated by an ellipse whose center (x, y) is at the top left of the sprite, and two radii for each axis
(radiusX, radiusY). As for rectangle collisions, they are associated with sprites indices. For instance, if sprites are
16x16 pixels, the collision of origin (4, 4) and radii (4, 4) makes a sprite not walkable on the circle of 8x8 pixels at
its top left.

NOTE: The origin (respectively center) of the rectangle (respectively ellipse) can be outside of the sprite. Likewise,
the size of the rectangle or ellipse can be greather than the one of the sprite. Consequently, the rectangle or ellipse
can overflow the sprite. *However*, the portion outside of the sprite will be ignored.

The file `solids.bin` contains any number of `SOLID_GROUP` concatenated together.

.`SOLID_GROUP`
|===
|0|1|2|3|4|5|6|7

2+|`SolidGroupIndex` 2+|`NumberOfShapes` 4+|`SHAPE` (0)
3+|(continued) 5+|`SHAPE` (1)
2+|(continued) 6+|(...)
7+|`SHAPE` (`NumberOfShapes` - 1) |
|===

`SolidGroupIndex`:: Unique identifier of this group, can be anything.
`NumberOfShapes`:: Number of shapes making up this group.

IMPORTANT: The solids are defined through the shapes they are made of. Nowhere there is a definition of a solid as a
list of shapes. There is only a list of shapes, some of which reference a single solid, effectively defining that solid.

.`SHAPE`
|===
|0|1|2|3|4|5|6

2+|`SolidIndex` |`ShapeType` 4+|`RECTANGLE` \| `ELLIPSE`
|===

`SolidIndex`:: Unique identifier of the solid owning this shape.
`ShapeType`:: Either a rectangle or ellipse, respectively `0` or `1`.

.`RECTANGLE`
|===
|0|1|2|3

|`PositionX` |`PositionY` |`Width` |`Height`
|===

`PositionX`:: Horizontal position of the rectangle's top left in the sprite in pixels.
`PositionY`:: Vertical position of the rectangle's top left in the sprite in pixels.
`Width`:: Width of the rectangle in pixels.
`Height`:: Height of the rectangle in pixels.

.`ELLIPSE`
|===
|0|1|2|3

|`CenterX` |`CenterY` |`RadiusX` |`RadiusY`
|===

`CenterX`:: Horizontal position of the ellipse's center in the sprite in pixels.
`CenterY`:: Vertical position of the ellipse's center in the sprite in pixels.
`RadiusX`:: Horizontal radius of the ellipse in pixels.
`RadiusY`:: Vertical radius of the ellipse in pixels.

NOTE: All the positions are interpreted as positive integers.

TIP: Remember that several shapes can be added for a single solid index. Every one of those will be checked to determine
whether an object collides with the solid.

==== Associating tiles to solids

The file `tile_solid_maps.bin` contains any number of `TILE_SOLID_ASSOCIATION` concatenated together.

.`TILE_SOLID_ASSOCIATION`
|===
|0|1|2|3

2+|`TileIndex` 2+|`SolidIndex`
|===

`TileIndex`:: Tile index in the tileset.
`SolidIndex`:: Index of the solid to use for collisions with the provided tile.

If a tile is not associated with any solid then it never collides with anything.

=== Characters

The file `characters.bin` contains any number of `CHARACTER` concatenated together.

.`CHARACTER`
|===
|0|1|2|3|4|5|6|7

2+|`SpritesetIndex` 2+|`ActionsToAnimationsGroup` 2+|`AnimationGroupIndex` 2+|`SolidIndex`
|`ControllerIndex` 7+|
|===

`SpritesetIndex`:: Index of the spriteset to use for this character.
`ActionsToAnimationsGroup`:: Index of the mapping of actions to animations to use for this character.
`AnimationGroupIndex`:: Index of the group of animations to use with this character.
`SolidIndex`:: Index of the solid to use for collisions with this character.
`ControllerIndex`:: The index of the controller which will handle the behavior of this character. For now there is only
a single controller which is the keyboard control, whose index is `0`.

=== Spritesets

A spriteset is the collection of sprites making up a character, a level or both. All the spritesets are defined in the
same file, however each have a corresponding picture file containing the index of its matching spriteset in its name.

The file `spritesets.bin` contains any number of `SPRITESET` concatenated together.

.`SPRITESET`
|===
|0|1|2|3|4|5|6|7

|`SpriteWidth` |`SpriteHeight` 2+|`SpritesetWidth` 2+|`SpritesetHeight` 2+|`OffsetLeft`
2+|`OffsetTop` 2+|`Gap` 2+|`PictureFileIndex` |`TransparencyRed` |`TransparencyGreen`
|`TransparencyBlue` 7+|
|===

`SpriteWidth`:: Width of the sprites in pixels.
`SpriteHeight`:: Height of the sprites in pixels.
`SpritesetWidth`:: Width of the spriteset in sprites.
`SpritesetHeight`:: Height of the spriteset in sprites.
`OffsetLeft`:: Number of pixels from the left border of the spriteset to the first sprite, used to ignore a margin in
the spriteset if there is one.
`OffsetTop`:: Number of pixels from the top border of the spriteset to the first sprite, used to ignore a margin in the
spriteset if there is one.
`Gap`:: Number of pixels between each sprites, used to ignore a margin in the spriteset separating the sprites if there
is one.
`PictureFileIndex`:: Index of the picture file to use (this matches the actual picture file to load which must be named
like this: `spriteset_N.bmp`, `N` being the index).
`TransparencyRed`:: Red component of the colour which will be turned transparent (0 to 255).
`TransparencyGreen`:: Green component of the colour which will be turned transparent (0 to 255).
`TransparencyBlue`:: Blue component of the colour which will be turned transparent (0 to 255).

TIP: There are also _charactersets_ and _tilesets_ which are special occurrences of spritesets. The former is a
spriteset dedicated to sprites of characters while the latter is dedicated to sprites of levels. Technically there is no
difference with a regular spriteset though, those are just names for convenience.

==== Sprite indices

Group of sprite indices mapping actions to the first sprite index of the animation in the characterset. The actions are:

. Walk left: 0
. Walk down: 1
. Walk right: 2
. Walk up: 3

A group of animation is made up of its index (two bytes), then of its size (two bytes). Then the couples of each action
mapped to the first sprite index of the animation for that action, concatenated. Both the action and sprite index are
two bytes each. Example of a map: 2 to 4 which means that the index of the first sprite of the animation showing the
character walk to the right (2) is at the fourth position in the characterset (4). Combined with the animation, this is
enough for finding all the (animated) sprites showing the character walking to the right.

== Quality

=== Project structure

The project structure is compliant with {3}[Canonical Project Structure] without exception. This document has been
submitted to the C++ standard and is sane and simple enough to work with.

The instructions in this document take precedence over the coding style used in the project.

=== Coding style

All the C++ code follows {2}[Google's {cpp} Style Guide], with two exceptions:

. Functions and methods are `camelBack` to avoid collisions with types
. Implementation source files have the `cpp` suffix, and header files have the `hpp` suffix (refer to the section about
the project structure)

Stick to the style as much as possible for the rest. The tool `clang-format` is available in the Docker container (and
Visual Studio Code will use it), and reads its configuration from link:.clang-format[`.clang-format`]. Likewise,
`clang-tidy` is also available, reads its configuration from link:.clang-tidy[`.clang-tidy`], and will check (among
other things) the naming of identifiers.

TIP: For quickly reformatting the code in Visual Studio Code, use `Ctrl+Shift+I`.

== Level editor

=== How to use

Move around using the right mouse button. Select a tile to place by left-clicking on it in the tileset view. Place a
tile by left-clicking on a location in the level view. Save the level by pressing `S`. The title bars display a `*` when
the work is not saved.

=== About animations

The editor plays the animations. However be aware that the animations will go out of sync when placing animated tiles
down: the animation starts playing immediately, which means two identical animated tiles can be at a different frame of
animation depending on when they were placed. To synchronize animations, restart the editor.

Note also that the speed of animations can slightly differ from the engine, depending on the performance of the editor.

== TODOs

. Continue the work on libraries: improve controllers in logic (and does logic have to depend on media?)
. Characters are updated every ticks. Add a parameter for updating them every N ticks instead (allows lower speeds)?
. Dedicated type for tiles / sprites instead of `uint16_t`
. Warning bug with readability-identifier-naming: https://stackoverflow.com/q/68475958 (upgrade clang-tidy?)
. Replace "pixel" by "point" in the code that does not deal with graphics
. Use namespaces
. Editor: synchronize animated tiles when placing them
. Objects or entities or whatever (including characters): each tile has a z-order sorted list of objects. Each tile
draws its objects respecting the z-order, *clipped* to the tile. So that multi-tiles objects are not a problem.
. Editor: resizable tileset window
. Tiled: https://www.mapeditor.org
