= FlatKiss
:1: https://en.wikipedia.org/wiki/KISS_principle
:2: https://google.github.io/styleguide/cppguide.html

FlatKiss is a 2D tile based demo game engine.

== Paradigm

First and foremost the mindset driving this project is *_simple_*. It embraces the {1}[KISS] principle. Simplicity comes
before performance / optimization. Simple is different from easy. It is easy to complicate things, but hard to make them
simple. In this project, before implementing anything the question which is asked is: "_Is this simple?_". If it is not,
then revamp it.

Concerns about performance only come after. When the project starts behaving slowly, *then* things can be torn to
accomodate performance. This is C++ with SDL, so unless doing crazy things performance often comes out of the box.

== How to build

The project uses CMake. There are not many dependencies, yet the simplest way is to use a Docker container which
contains everything needed.

WARNING: The Docker image is not yet accessible anywhere. The only way to get it is to build it. There is a temporary
script which does that in addition to generating binary files containing the assets for the engine to use:
`setup_dev_environment.sh`. Note that it will download pictures which must be converted manually to the BMP file format.

When the image is ready, the recommended way is to use Visual Studio Code. The only extension required is _Remote -
Containers_, install it first. Then open the directory of the project with Visual Studio Code, and it will detect that a
Docker image can be used for the project. Follow the recommendations of Visual Studio Code (such as configuring the
project, etc...), then click "Build".

== How to run

Assets are required for the engine to actually show something. Refer to the previous section for how to generate them.
Then, outside of the Docker container, run the binary generated by CMake in the `build/` directory (it might require to
be ran from the project's root directory in order to find the assets).

== Binary files format

=== Level

Width and height of the level in tiles on two bytes each, followed by the spriteset index to use on two bytes, followed
by the list of tiles indices (in the tileset) as shorts (two bytes per index, little endian).

=== Animations

The _period_ of the animation is the number of tiles making it up. It is stored on one byte. The _duration_ of the
animation is how many ticks pass before the animation goes to the next step / tile. Stored on the next byte. Then are
the tiles indices (in the tileset) as shorts (two bytes per index, little endian).

A group of animation starts with the index on two bytes. Then the number of animations making up the group on two bytes.
Then come the animations concatenated together.

=== Collisions

Collisions are either rectangles or ellipses which cannot be crossed. There are gathered in groups making up solids. A
solid is a collection of those shapes which cannot be crossed.

Rectangle collisions are delimitated by an origin (x, y) at the top left of the sprite, and a size (width, height). They
are associated with sprites indices. For instance, if sprites are 16x16 pixels, the collision of origin (12, 12) and
size (4, 4) makes a sprite not walkable on the square of 4x4 pixels at its bottom right.

Ellipse collisions are delimitated by an ellipse whose center (x, y) is at the top left of the sprite, and two radii for
each axis (radiusX, radiusY). As for rectangle collisions, they are associated with sprites indices. For instance, if
sprites are 16x16 pixels, the collision of origin (4, 4) and radii (4, 4) makes a sprite not walkable on the circle of
8x8 pixels at its top left.

NOTE: The origin (respectively center) of the rectangle (respectively ellipse) can be outside of the sprite. Likewise,
the size of the rectangle or ellipse can be greather than the one of the sprite. Consequently, the rectangle or ellipse
can overflow the sprite. *However*, the portion outside of the sprite will be ignored.

A collision is stored as:

. First two bytes: solid index
. Next byte: collision type (0 for rectangle, 1 for circle)
. *For a rectangle*: on the four next bytes (each on one byte): x, y, width, height
. *For an ellipse*: on the four next bytes (each on one byte): x center, y center, x radius, y radius

All of those are interpreted as positive integers.

TIP: Several collisions can be added for a single solid index. Every one of those will be checked to determine whether
an object collides with the solid.

A group of solids starts with the index on two bytes. Then the number of solids making up the group on two bytes. Then
come the solids (meaning all the collisions making up all the solids of that group) concatenated together.

==== Tiles and solids

Either nothing is specified for a tile (it has no solid, i.e. never collides with anything) or it maps to the index of
the solid to use. This is first the index of the tile on two bytes, followed by the index of the solid on two bytes.

=== Characters

As many characters can be defined as one like. A character is defined like this:

. Initial X position (eight byte)
. Initial Y position (eight byte)
. Index of the spriteset to use (two bytes)
. Index of the group of sprite indices to use with the spriteset (two bytes)
. Index of the character animation to use with the spriteset (two bytes)
. Index of the solid to use (two bytes)
. Index of the controller to use (one byte)

Just append the characters for adding more than one.

==== Spritesets

A spriteset is the set of sprites making up a character, a level or both. All the spritesets are defined in the same
file, however each have a corresponding picture file containing the index of its matching spriteset in its name. A
spriteset is defined by:

. Width of the sprites in pixels (one byte)
. Height of the sprites in pixels (one byte)
. Width of the spriteset in sprites (two bytes)
. Height of the spriteset in sprites (two bytes)
. Number of pixels from the left border of the spriteset to the first sprite (two bytes)
. Number of pixels from the top border of the spriteset to the first sprite (two bytes)
. Number of pixels between each sprites, called gap (two bytes)
. Index of the picture file to use (this matches the actual picture file to load) (two bytes)
. Red component of the colour which will be turned transparent (one byte)
. Green component of the colour which will be turned transparent (one byte)
. Blue component of the colour which will be turned transparent (one byte)

TIP: There are also _charactersets_ and _tilesets_ which are special occurrences of spritesets. The former is a
spriteset dedicated to sprites of characters while the latter is dedicated to sprites of levels. There are no
differences with a regular spriteset though, those are just names for convenience.

==== Sprite indices

Group of sprite indices mapping actions to the first sprite index of the animation in the characterset. The actions are:

. Walk left: 0
. Walk down: 1
. Walk right: 2
. Walk up: 3

A group of animation is made up of its index (two bytes), then of its size (two bytes). Then the couples of each action
mapped to the first sprite index of the animation for that action, concatenated. Both the action and sprite index are
two bytes each. Example of a map: 2 to 4 which means that the index of the first sprite of the animation showing the
character walk to the right (2) is at the fourth position in the characterset (4). Combined with the animation, this is
enough for finding all the (animated) sprites showing the character walking to the right.

== Quality

=== Coding style

All the C++ code follows {2}[Google's {cpp} Style Guide], with two exceptions:

. Functions and methods are `camelBack` to avoid collisions with types
. Implementation source files have the `cpp` suffix, and header files have the `hpp` suffix

Stick to the style as much as possible for the rest. The tool `clang-format` is available in the Docker container (and
Visual Studio Code will use it), and reads its configuration from link:.clang-format[`.clang-format`]. Likewise,
`clang-tidy` is also available, reads its configuration from link:.clang-tidy[`.clang-tidy`], and will check (among
other things) the naming of identifiers.

TIP: For quickly reformatting the code in Visual Studio Code, use `Ctrl+Shift+I`.

== Editor

=== How to use

Move around using the right mouse button. Select a tile to place by left-clicking on it in the tileset view. Place a
tile by left-clicking on a location in the level view. Save the level by pressing `S`. The title bars display a `*` when
the work is not saved.

=== About animations

The editor plays the animations. However be aware that the animations will go out of sync when placing animated tiles
down: the animation starts playing immediately, which means two identical animated tiles can be at a different frame of
animation depending on when they were placed. To synchronize animations, restart the editor.

Note also that the speed of animations can slightly differ from the engine, depending on the performance of the editor.

== TODOs

. Characters are updated every ticks. Add a parameter for updating them every N ticks instead (allows lower speeds)?
. Use struct when reading files
. Dedicated type for tiles / sprites instead of `uint16_t`
. Better directory structure
. Warning bug with readability-identifier-naming: https://stackoverflow.com/q/68475958 (upgrade clang-tidy?)
. Check whether the built binary can run on a system without libsdl2
. Replace "pixel" by "point" in the code that does not deal with graphics
. Editor: synchronize animated tiles when placing them
. Objects or entities or whatever (including characters): each tile has a z-order sorted list of objects. Each tile draws its objects respecting the z-order, **clipped** to the tile. So that multi-tiles objects are not a problem.
. Editor: resizable tileset window
. Tiled: https://www.mapeditor.org
