= Architecture
:toc:
:1: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1204r0.html
:2: https://google.github.io/styleguide/cppguide.html
:3: https://cmake.org
:4: https://github.com/mcmtroffaes/inipp
:5: https://www.libsdl.org
:6: https://clang.llvm.org/extra/clang-tidy
:7: https://clang.llvm.org/docs/ClangFormat.html

Explanation about the structure and inner workings of the project.

== Quality

=== File tree

The project is compliant with {1}[Canonical Project Structure] without exception. This document has been submitted to
the C++ standard and is sane and simple enough to work with.

The instructions in this document take precedence over the coding style used in the project.

=== Coding style

All the C++ code follows {2}[Google's {cpp} Style Guide], with two exceptions:

. Functions and methods are `camelBack` to avoid collisions with types
. Implementation source files have the `cpp` suffix, and header files have the `hpp` suffix (refer to the section about
the project structure)

Stick to the style as much as possible for the rest. The tool `clang-format` is available in the Docker container (and
Visual Studio Code will use it), and reads its configuration from link:.clang-format[`.clang-format`]. Likewise,
`clang-tidy` is also available, reads its configuration from link:.clang-tidy[`.clang-tidy`], and will check (among
other things) the naming of identifiers.

TIP: For quickly reformatting the code in Visual Studio Code, use `Ctrl+Shift+I`.

== Project structure

To avoid coupling between unrelated code, the project is split into libraries. Each library is its own CMake project,
effectively preventing unwanted dependencies to appear.

At the top of the libraries there is an executable `flatkiss` which glues them together.

The libraries are:

. `libflatkiss-data`: loads the assets and feed them to the model.
. `libflatkiss-logic`: contains the algorithms (e.g. collision detection), directs the media library and more generally
runs the engine.
. `libflatkiss-media`: interfaces with the graphics, input events, and everything related to I/O with the user.
. `libflatkiss-model`: stores the data model representing the state of the game (levels, characters, etc...).

=== Inner dependencies

IMPORTANT: _Work in progress, will contain a dependency diagram generated by CMake._

=== Outer dependencies

Here are the dependencies for building the project:

. a C++ compiler
. {3}[CMake] for generating the build configuration
. {4}[IniPP] for loading the engine configuration
. {5}[SDL2] which is the graphic library and also handles the events and so on
. {6}[clang-tidy] and {7}[clang-format] for automatically formatting the source code (optional)

WARNING: SDL2 is also required at runtime as it is dynamically linked to the engine.

For more information on how to setup the environment with these tools, refer to link:environment.adoc[Environment].

== Libraries

=== `libflatkiss-data`

This library loads the assets from disk (but could be from any other source) and feed them to the model. The assets are:

- pictures making up the spritesets
- levels
- characters
- collisions
- etc...

The pictures are stored as actual BMP picture files. The rest are binary files containing information about a particular
asset (e.g. levels).

==== Binary files format

[NOTE]
====
- Everything is little-endian.
- In the tables below, names in `PascalCase` are just values, names in `MACRO_CASE` are other bytefields.
- In the tables below, _(continued)_ means a value of bytefield which extends onto the next row.
- In the tables below, the empty cells which come last must be ignored.
====

WARNING: In the tables below, sometimes values or bytefields follow a _(...)_ on a new row. This does not necessarily
means that this value / bytefields is padded to 0. In all cases, this field just follows whatever was before without a
gap.

===== Level

The file `levels.bin` contains any number of `LEVEL` concatenated together.

.`LEVEL`
|===
|0|1|2|3|4|5|6|7

2+|`Width` 2+|`Height` 2+|`SpritesetIndex` 2+|`AnimationGroupIndex`
2+|`TilesToSolidsMapIndex` 2+|`NumberOfCharacters` 4+|`CHARACTER_IN_LEVEL` (0)
2+|(continued) 6+|`CHARACTER_IN_LEVEL` (1)
2+| (...) 6+|`CHARACTER_IN_LEVEL` (`NumberOfCharacters` - 1)
2+|`TileIndex` (0) 2+|`TileIndex` (1) 2+| (...) 2+|`TileIndex` (`Width` * `Height` - 1)
|===

`Width`:: Width of the level in tiles.
`Height`:: Height of the level in tiles.
`SpritesetIndex`:: Index of the spriteset to use for the level.
`AnimationGroupIndex`:: Index of the group of animations to use for the level.
`TilesToSolidsMapIndex`:: Index of the map of tiles to solids to use for the level.
`NumberOfCharacters`:: Number of characters in the level.
`TileIndex`:: Tile index in the tileset. The first tile index represents the top left tile in the level, then next tile
index represents the one to its right, and so on until reaching the bottom right tile in the level.

.`CHARACTER_IN_LEVEL`
|===
|0|1|2|3|4|5

2+|`CharacterIndex` 2+|`PositionX` 2+|`PositionY`
|===

`CharacterIndex`:: Index of the character to use.
`PositionX`:: Location in the level of the character in tiles along the horizontal axis.
`PositionY`:: Location in the level of the character in tiles along the vertical axis.

===== Animations

The file `animations.bin` contains any number of `ANIMATION_GROUP` concatenated together.

.`ANIMATION_GROUP`
|===
|0|1|2|3|4|5|6|7

2+|`AnimationGroupIndex` 2+|`NumberOfAnimations` 4+|`ANIMATION` (0)
4+|`ANIMATION` (1) 4+|(...)
4+|`ANIMATION` (`NumberOfAnimations` - 1) 4+|
|===

`AnimationGroupIndex`:: Unique identifier of this group, can be anything.
`NumberOfAnimations`:: Number of animations this group is made of.

.`ANIMATION`
|===
|0|1|2|3|4|5|6|7

|`Period` |`Duration` 2+|`SpriteIndex` (0) 2+|`SpriteIndex` (1) 2+|(...)
2+|`SpriteIndex` (`Period` - 1) 6+|
|===

`Period`:: Number of sprites making up this animation.
`Duration`:: How many ticks pass before the animation goes to the next step / sprite.
`SpriteIndex`:: Sprite index in the spriteset. The first sprite index is the first frame of the animation, the second
sprite index the second frame, etc...

TIP: The first sprite index in the animation also defines which animation is played for a particular sprite (in a level
or of a character). A group of animations is associated with a level / character. Then the animation for a particular
sprite is the one starting with that sprite index.

===== Collisions

Collisions are handled through the use of shapes which cannot be crossed. The shapes available are rectangles and
ellipses. Those are gathered in groups making up _solids_. A solid is a collection of those shapes which cannot be
crossed.

Rectangle are delimitated by an origin (x, y) at the top left of the sprite, and a size (width, height). They are
associated with sprites indices. For instance, if sprites are 16x16 pixels, the collision of origin (12, 12) and size
(4, 4) makes a sprite not walkable on the square of 4x4 pixels at its bottom right.

Ellipse are delimitated by an ellipse whose center (x, y) is at the top left of the sprite, and two radii for each axis
(radiusX, radiusY). As for rectangle collisions, they are associated with sprites indices. For instance, if sprites are
16x16 pixels, the collision of origin (4, 4) and radii (4, 4) makes a sprite not walkable on the circle of 8x8 pixels at
its top left.

NOTE: The origin (respectively center) of the rectangle (respectively ellipse) can be outside of the sprite. Likewise,
the size of the rectangle or ellipse can be greather than the one of the sprite. Consequently, the rectangle or ellipse
can overflow the sprite. *However*, the portion outside of the sprite will be ignored.

The file `solids.bin` contains any number of `SOLID_GROUP` concatenated together.

.`SOLID_GROUP`
|===
|0|1|2|3|4|5|6|7

2+|`SolidGroupIndex` 2+|`NumberOfShapes` 4+|`SHAPE` (0)
3+|(continued) 5+|`SHAPE` (1)
2+|(continued) 6+|(...)
7+|`SHAPE` (`NumberOfShapes` - 1) |
|===

`SolidGroupIndex`:: Unique identifier of this group, can be anything.
`NumberOfShapes`:: Number of shapes making up this group.

IMPORTANT: The solids are defined through the shapes they are made of. Nowhere there is a definition of a solid as a
list of shapes. There is only a list of shapes, some of which reference a single solid, effectively defining that solid.

.`SHAPE`
|===
|0|1|2|3|4|5|6

2+|`SolidIndex` |`ShapeType` 4+|`RECTANGLE` \| `ELLIPSE`
|===

`SolidIndex`:: Unique identifier of the solid owning this shape.
`ShapeType`:: Either a rectangle or ellipse, respectively `0` or `1`.

.`RECTANGLE`
|===
|0|1|2|3

|`PositionX` |`PositionY` |`Width` |`Height`
|===

`PositionX`:: Horizontal position of the rectangle's top left in the sprite in pixels.
`PositionY`:: Vertical position of the rectangle's top left in the sprite in pixels.
`Width`:: Width of the rectangle in pixels.
`Height`:: Height of the rectangle in pixels.

.`ELLIPSE`
|===
|0|1|2|3

|`CenterX` |`CenterY` |`RadiusX` |`RadiusY`
|===

`CenterX`:: Horizontal position of the ellipse's center in the sprite in pixels.
`CenterY`:: Vertical position of the ellipse's center in the sprite in pixels.
`RadiusX`:: Horizontal radius of the ellipse in pixels.
`RadiusY`:: Vertical radius of the ellipse in pixels.

NOTE: All the positions are interpreted as positive integers.

TIP: Remember that several shapes can be added for a single solid index. Every one of those will be checked to determine
whether an object collides with the solid.

====== Associating tiles to solids

The file `tile_solid_maps.bin` contains any number of `TILE_SOLID_ASSOCIATION` concatenated together.

.`TILE_SOLID_ASSOCIATION`
|===
|0|1|2|3

2+|`TileIndex` 2+|`SolidIndex`
|===

`TileIndex`:: Tile index in the tileset.
`SolidIndex`:: Index of the solid to use for collisions with the provided tile.

If a tile is not associated with any solid then it never collides with anything.

===== Characters

The file `characters.bin` contains any number of `CHARACTER` concatenated together.

.`CHARACTER`
|===
|0|1|2|3|4|5|6|7

2+|`SpritesetIndex` 2+|`ActionsToAnimationsGroup` 2+|`AnimationGroupIndex` 2+|`SolidIndex`
|`ControllerIndex` 7+|
|===

`SpritesetIndex`:: Index of the spriteset to use for this character.
`ActionsToAnimationsGroup`:: Index of the mapping of actions to animations to use for this character.
`AnimationGroupIndex`:: Index of the group of animations to use with this character.
`SolidIndex`:: Index of the solid to use for collisions with this character.
`ControllerIndex`:: The index of the controller which will handle the behavior of this character. For now there is only
a single controller which is the keyboard control, whose index is `0`.

===== Spritesets

A spriteset is the collection of sprites making up a character, a level or both. All the spritesets are defined in the
same file, however each have a corresponding picture file containing the index of its matching spriteset in its name.

The file `spritesets.bin` contains any number of `SPRITESET` concatenated together.

.`SPRITESET`
|===
|0|1|2|3|4|5|6|7

|`SpriteWidth` |`SpriteHeight` 2+|`SpritesetWidth` 2+|`SpritesetHeight` 2+|`OffsetLeft`
2+|`OffsetTop` 2+|`Gap` 2+|`PictureFileIndex` |`TransparencyRed` |`TransparencyGreen`
|`TransparencyBlue` 7+|
|===

`SpriteWidth`:: Width of the sprites in pixels.
`SpriteHeight`:: Height of the sprites in pixels.
`SpritesetWidth`:: Width of the spriteset in sprites.
`SpritesetHeight`:: Height of the spriteset in sprites.
`OffsetLeft`:: Number of pixels from the left border of the spriteset to the first sprite, used to ignore a margin in
the spriteset if there is one.
`OffsetTop`:: Number of pixels from the top border of the spriteset to the first sprite, used to ignore a margin in the
spriteset if there is one.
`Gap`:: Number of pixels between each sprites, used to ignore a margin in the spriteset separating the sprites if there
is one.
`PictureFileIndex`:: Index of the picture file to use (this matches the actual picture file to load which must be named
like this: `spriteset_N.bmp`, `N` being the index).
`TransparencyRed`:: Red component of the colour which will be turned transparent (0 to 255).
`TransparencyGreen`:: Green component of the colour which will be turned transparent (0 to 255).
`TransparencyBlue`:: Blue component of the colour which will be turned transparent (0 to 255).

TIP: There are also _charactersets_ and _tilesets_ which are special occurrences of spritesets. The former is a
spriteset dedicated to sprites of characters while the latter is dedicated to sprites of levels. Technically there is no
difference with a regular spriteset though, those are just names for convenience.

===== Actions to animations

The file `action_sprite_maps.bin` contains any number of `ACTIONS_TO_ANIMATIONS_GROUP` concatenated together.

.`ACTIONS_TO_ANIMATIONS_GROUP`
|===
|0|1|2|3|4|5|6|7

2+|`ActionsToAnimationsGroup` 2+|`GroupSize` 4+|`ACTION_TO_ANIMATION` (0)
4+|`ACTION_TO_ANIMATION` (1) 4+|(...)
4+|`ACTION_TO_ANIMATION` (`GroupSize` - 1) 4+|
|===

`ActionsToAnimationsGroup`:: Unique identifier of this group.
`GroupSize`:: Number of mappings in this group.

.`ACTION_TO_ANIMATION`
|===
|0|1|2|3

2+|`ActionIndex` 2+|`SpriteIndex`
|===

`ActionIndex`:: Index of the action to map to the animation. The possible actions are:
    - Walk left: `0`
    - Walk down: `1`
    - Walk right: `2`
    - Walk up: `3`
`SpriteIndex`:: Index of the first sprite of the animation to link with the action.

TIP: Example of a mapping: 2 to 4 which means that the index of the first sprite of the animation showing the character
walk to the right (2) is at the fourth position in the characterset (4). Combined with the animation, this is enough for
finding all the (animated) sprites showing the character walking to the right.

=== `libflatkiss-logic`

The brain of the engine. This is where the controllers reside, where the algorithms such as moving characters around
unfold, etc... It makes the model come to life.

=== `libflatkiss-media`

Draws the game to screen, listens for user events such as keyboard events, and more generally handles everything related
to I/O with the user:

- window creation
- picture loading
- rendering the game
- event handling

=== `libflatkiss-model`

All the information about levels, characters, collisions, animations, and so on are stored in the model. The model is a
collection of classes which represents the state of the game. It does nothing on its own, it is created from the data
loaded by the data library, and evolves thanks to the controllers in the logic library.
